# Tecniche anti-debugging  
*[MITRE ID: T1622](https://attack.mitre.org/techniques/T1622/)*

## Uso delle API di Windows

Uno dei metodi più semplici utilizzato dai malware per individuare la presenza di un debugger in esecuzione è attraverso l'utilizzo di API di Windows:
- **[IsDebuggerPresent](https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent)**: cerca il campo `IsDebugged/BeingDebugged` all'interno del PEB
- **[CheckRemoteDebuggerPresent](https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-checkremotedebuggerpresent)**: cerca il campo `IsDebugged/BeingDebugged` all'interno del PEB ma di un altro processo nel sistema o se stesso
- **[NtQueryInformationProcess](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess)**: il secondo parametro della funzione, `ProcessInformationClass`, accetta diversi valori tra cui `0x7` (*ProcessDebugPort*) che restituisce la porta a cui è connesso il debugger, se presente
- **[OutputDebugString](https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringw)**: questa funzione invia una stringa di testo al debugger da stampare a video e può essere sfruttata per testare la presenza di un eventuale debugger abbinata a una funzione come **SetLastError**. Se esiste un debugger attaccato al processo, il valore personalizzato passato come argomento di **SetLastError** è recuperato. Se il debugger non è presente il valore risultato dell'operazione recuperato con **GetLastError** sarà diverso da quello personalizzato.
- **[EnumWindows](https://learn.microsoft.com/it-it/windows/win32/api/winuser/nf-winuser-enumwindows)** cercando tra le finestre aperte nomi come _debug_, _dbg_, _debugger_ + **[SuspendThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread)** per sospendere l'eventuale debugger trovato

## Controllo manuale delle structs

Le chiamate alle API di Windows sono facilmente alterabili per mezzo di rootkit che effettuano l'hooking alle API selezionate possono restituire valori diversi dalla realtà, ad esempio un valore NULL per IsDebuggerPresent.  

Per bypassare questa tecnica difensiva, un malware può contenere codice che gli permette di verificare direttamente lo stato dei flag accedendo direttamente al **[PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)**.  
Il `Process Environment Block` è una struttura dell'architettura Windows che contiene informazioni, per singolo processo, circa l'ambiente di esecuzione. Alcune di queste informazioni non sono documentate.  

È possibile accedere al PEB al pointer `fs:[30h]`.

### Verificare se il flag BeingDebugged è attivo

L'offset `fs:[30h+2]` contiene il flag per **BeingDebugged** che se impostato su **1** significa che il processo è monitorato da un debugger.

Due tecniche per controllare il flag sono:

```
mov eax, dword ptr fs:[30h]
mov ebx, byte ptr [eax+2]
test ebx, ebx
jz NoDebbugerDetected
```
```
push dword fs[30h]
pop edx
cmp byte ptr [edx+2], 1
je DebuggerPresent
```

### Verificare i flag al campo Reserved4 (legacy)

La location Reserved4, non documentata da Microsoft, è definita come `ProcessHeap` all'offset `0x18`. Questo primo heap contiene un header con due campi `ForceFlags` e `Flags` che informano il kernel se l'heap è stato creato da un debugger.  

L'offset `0x10` all'interno dell'header corrisponde a `ForceFlags` mentre (il cui valo l'offset `0x0C` corrisponde a `Flagsre spesso corrisponde a *ForceFlags* ma passato attraverso calcolo OR con valore 2).  

```
mov eax, large fs:30h
mov eax, dword ptr [eax+18h]
cmp dword ptr ds:[eax+10h], 0
jne DebuggerDetected
```

### Verificare il flag NTGlobalFlag

Le istruzioni su come creare l'heap nel caso di processo avviato da debugger sono contenute in una location non documentata nel PEB all'offset `0x68`.  
Se il valore in questa location è pari a `0x70` significa che c'è un debugger in esecuzione attaccato al processo.  

Il valore `0x70` corrisponde a `(FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)`.  

```
mov eax, large fs:30h
cmp dword ptr ds:[eax+68h], 70h
jz DebuggerDetected
```

## Cercare riferimenti a residui di sistema lasciati da debugger

Strumenti di debugging lasciano residui nel sistema mentre sono in esecuzione come ad esempio il percorso del Registro di Sistema `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AeDebug`.  
Questa chiave di Registro specifica quale debugger attivare quando un'applicazione genera un errore, di default impostato su *Dr.Watson*.  
Se il valore punta a un altro debugger è molto probabile che sia in esecuzione e che stia analizzando un'applicazione.  

Lo stesso vale per file e cartelle usati da debugger o da finestre attive (vedi esempio sopra).  

## Identificare il comportamento dei debuggers

La manipolazione del flusso di esecuzione del file analizzato avviene attraverso la manipolazione di diversi elementi che possono essere monitorati al fine di identificare un debugger.

### INT Scanning

Un breakpoint **software** è una istruzione `INT 3` usata da debugger per alterare temporaneamente un'istruzione e ottenere il controllo al momento dell'eccezione.  
L'opcode per `INT 3` è `0xCC`.  

In alternativa debugger usano `INT immediate` il cui opcode è `0xCD valore`.  

### Verifica Code Checksum

Ripetuti confronti a sezioni interne dopo calcolo CRC o MD5 di una sezione al fine di verificarne l'integrità.  

### Timing checks

Il processo di debug di un file ne rallenta inevitabilmente l'esecuzione.  
Due tecniche di rilevamento di un debugger controllando il tempo di esecuzione dell'eseguibile e si concentrano:
- l'una sul catturare ripetutamente timestamp e di confrontarli per determinare la quantità di tempo trascorsa tra le operazioni
- l'altra di cattura i timestamp prima e dopo la generazione di un errore e calcolare il tempo di gestione dell'eccezione che in normali condizioni di esecuzione avviene in pochissimo tempo

Attraverso la funzione **[rdtsc](https://learn.microsoft.com/en-us/cpp/intrinsics/rdtsc?view=msvc-170)** (opcode `0x0F31`) un malware recupera il numero di tick (cicli di clock) del processore dall'ultimo reset/riavvio. Questa funzione ritorna un valore a 64 bit memorizzato in EDX:EAX.  
Questo valore è confrontato con altri valori per determinare *anomalie* nel tempo di utilizzo del sistema e determinare quale ramo/salto effettuare.  

L'API di Windows **[QueryPerformanceCounter](https://learn.microsoft.com/it-it/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter)** è utilizzata per recuperare il valore del contatore delle performance in letture sequenziali il cui confronto può rivelare la presenza di un debugger (delta alto).  
L'API di Windows **[GetTickCount](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount)** è utilizzata per recuperare i millisecondi trascorsi dall'ultimo riavvio di sistema, seguito poi dal confronto con un valore statico.


## Manipolare il funzionamento del debugger

### TLS Callback
[*ID: T1055.005*](https://attack.mitre.org/techniques/T1055/005/)

Generalmente i debugger fermano l'esecuzione di un file eseguibile all'entrypoint come definito del file PE.  
Una TLS callback permette di eseguire codice prima il debugger si fermi all'entrypoint, in questo modo bypassando il funzionamento predefinito del debugger ed eseguendo codice che rimane nascosto all'analisi.  

Thread Local Storage è una classe di storage di Windows che permette a ogni thread di mantenere un valore differente per una variabile dichiarata usando TLS.

Quando un file PE utilizza TLS, generalmente è presente una sezione **.tls** nell'header. Oltre alla ricerca della sezione è utile anche elencare, in un programma di RE, gli l'entrypoint esposti dal file PE.  

### Gestione delle eccezioni

Siccome i debugger, per impostazione predefinita, sono configurati per intercettare eccezioni e controllare l'esecuzione dei processi, i malware possono generare eccezioni volontarie in modo da determinare la presenza di debugger dal codice di errore risultato dall'operazione.

### Inserimento di interrupt

I debugger utilizzano determinati valori, come `INT 3` (`0xCC`), per alterare temporaneamente il codice, generare eccezioni e prendere il controllo sull'esecuzione.  
I creatori di malware sfruttano questo comportamento inserendo all'interno del codice del malware istruzioni che il debugger interpreta come segnali di stop/eccezione.

- `INT 3` (`0xCC`)
- `INT 3` (`0xCD03`) = specifico per windbg se ancora valido
- `INT 0x2D` - kernel debugger breakpoint
- `icebp` (`0xF1`)



- manomissione di file legati ai debuggers per prevenirne l'uso
- sviluppo di codice in grado di modificarsi durante l'esecuzione rendendo molto più complicato l'analisi del codice tramite debugger