# Tipi di disassembler

Le tecniche per ostacolare l'analisi di codice assembly di malware sono implementate sfruttano errori nelle logiche di interpretazione dei byte da parte dei programmi disassembler.

I programmi sfruttano due tipi di logiche di interpretazione dei byte: **Linear disassembly** e **flow-oriented disassembly**.  

## Linear disassembly

Analisi dei byte una riga per volta. La dimensione della riga è usata come separatore per iniziare l'analisi dell'istruzione/riga successiva.  

Un disassembler lineare non tiene in considerazione il flusso del codice e analizza incondizionatamente le istruzioni, una di seguito all'altra, interpretando i byte sulla sola base della dimensione dell'istruzione.  

Questo comporta che in casi dove coesistono byte di codice e byte di dati, il disassembler crei un disassemblato che non rispecchia la vera struttura del file binario.  

## Flow-Oriented Disassembly

Analisi dei byte tenendo in considerazione il significato dell'istruzione e quindi riconscendo salti condizionali, eccezioni e altre azioni che rendono il codice non-lineare.  

In questi casi il disassembler prima itera il codice, memorizzando eventuali ramificazioni creando una mappa delle chiamate e dei pointer.  
Successivamente, sulla base della mappa creata il disassembler riconosce come e quando disassemblare il codice e come riconoscerne il vero significato.  

Nel caso di ramificazioni, quindi un ramo "vero" e uno "falso", e nel caso di conflitti questo algoritmo tende a favorire prima l'analisi dei rami "falsi".  

Nel caso di chiamate a funzione `call`, il disassembler ancora una volta mappa la posizione prima di procedere all'analisi del codice.

Nella maggior parte dei disassembler è possibile correggere manualmente l'output nell'eventualità che il programma abbia interpretato in maniera errata i byte mischiando o spezzando byte di istruzioni in dati e viceversa.  


# Tecniche anti-disassembly

## Istruzioni `jmp` alla stessa destinazione

Due istruzioni di salto condizionale come `jz` e `jnz` una di seguito all'altra che puntano alla stessa destinazione, altro non sono che una istruzione `jump`, salto non condizionale.  

Nel caso di ramificazioni i disassembler prediligono analizzare il ramo che segue un risultato *false*.  
La prima analisi di un disassembler potrebbe risultare errata, errore da cui gli opcode potrebbero essere interpretati in modo sbagliato.  

Ad esempio, l'opcode `0xE8` identifica l'istruzione `call` oppure il valore `0E8h`. Un disassembler ingannato da una tecnica di anti-disassembly produrre un output sbagliato, restituendo una chiamata inesistente a una funzione inesistente.  

## Istruzioni `jmp` con una  condizione costante

Questa tecnica inizia con l'azzeramento di un registro tramite funzione `xor`, ad esempio `xor eax, eax` azzera il registro eax e imposta il flag **ZF**.  
L'istruzione che segue è un `jz`, ovvero salta se lo Zero Flag è impostato. Questa istruzione è sempre vera e quindi il salto in realtà non è condizionato da una variabile. Il flag ZF è sempre impostato dall'istruzione precedente.  

Come la tenica sopra, lo scopo è di nascondere i byte alla vista del disassembler e causare errori nella logica di interpretazione del codice, trasformando completamente le istruzioni successi.  

***Le due tecniche precedenti si basano sullo stesso concetto ovvero inserire in un punto strategico del codice un byte (rogue byte) che, quando è interpretato da un disassembler, può corrispondere a una operazione multibyte. In realtà questo byte può essere ignorato e quindi, a seguito di una correzione manuale, il disassembler riesce a interpretare correttamente il codice e a produrre un output che abbia senso.***

## "Impossible disassembly"

Questa tecnica prevede che la costruzione di un complicato NOP. Nello specifico si tratta di una sequenza di byte di cui uno è comune a due operazioni.  

Ad esempio:

|JMP-1|JMP-1\INC EAX|INC EAX|DEC EAX|
|-|-|-|-|
|EB|FF|C0|48|

Il byte `FF` è sia parte dell'istruzione `jmp-1` (operazione che salta al secondo byte di sè stesso ed è una operazione valida perché `FF` è anche il primo byte dell'istruzione successiva) sia parte dell'istruzione `inc eax`. A seguire l'istruzione `dec eax` annulla l'incremento di fatto risultando in un `NOP`.

Il modo più semplice per constrastare questo tipo di tecniche è di agire manualmente sul codice, trasformando l'intera sequenza di byte in NOPs oppure in dati (scorciatoia `D` in IDA PRO).  


## Interruzione con `retn`

L'istruzione `retn`, opposta a `call`, è solitamente utilizzata alla fine di una funzione per restituire il valore calcolato dalla funzione, appunto, rimuovere dallo stack le variabili locali alla funzione e saltare all.  

Quando `retn` è utilizzato in modo inatteso può causare una lettura errata del codice da parte dei disassemblers. Ad esempio, se si inserisce l'istruzione `retn` preceduta da un calcolo che produce un ipotetico indirizzo a cui saltare, un disassembler potrebbe interpretare male il codice e non correlare tra loro gli argomenti/bìvariabili. In questo caso, l'istruzione che si trova a quell'ipotetico indirizzo non avrebbe riferimenti rimanendo, di conseguenza,  nell'ombra, o meglio senza commenti/riferimenti in chiaro.  


## SEH - Structured Exception Handler Misuse

I sistemi operativi offrono meccanismi di gestione controllata delle eccezioni fornendo una struttura di "gestione delle eccezioni", SEH.

Una catena SEH è generalmente uno `struct` nominato **EXCEPTION_REGISTRATION**.  
Al fine di individuarla, un OS dapprima analizza il registro **FS**, da cui estrae informazioni per leggere il contenuto del segmento **TEB** (Thread Evironment Block).  
La prima struttura nel TEB è il **TIB** (Thread Information Block).  
Il primo elemento del TIB (e d conseguenza i primi byte del TEB) è un pointer alla catena SEH.  

Il primo elemento nel record EXCEPTION_REGISTRATION punta al record precedente. Il secondo campo è un pointer all'handler della funzione.  

Concettualmente funziona come un piccolo stack dove il primo record è l'ultimo a essere aggiunto alla lista. Quando le eccezioni non sono gestite si raggiunge uno stato di *unhandled exception* con conseguente messaggio di errore.  

Siccome il flusso di controllo offerto dal SEH non seguito con cagilita da disassemblers e debuggers, riuscire a inserire un record all'inizio della lista per nascondere/offuscare il codice risulta essere una tecnica utile contro l'analisi statica/dinamica avanzata.  

Per inserire il record è necessario accedere al registro FS e passare due argomenti tramite push. Esistono sitemi di sicurezza per impedire la manomissione della catena SEH che possono essere disattivate in fase di compilazione del programma.

La correzione richiede sempre un intervento manuale.

https://coalfire.com/the-coalfire-blog/the-basics-of-exploit-development-2-seh-overflows