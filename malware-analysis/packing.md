# Packers

I packers sono strumenti il cui scopo è di nascondere un file eseguibile all'interno di un altro file eseguibile rendendo quindi *impossibile* analizzare staticamente il malware.

Quando un file *packed* viene eseguito, il sistema operativo carica l'*unpacking stub* che:
1. estrae in memoria il file originale
2. risolve tutti gli import del file eseguibile originale
3. passa l'esecuzione all'OEP (original entry point)

.1 Quando un file PE viene eseguito, un loader legge l'header PE e crea in memoria lo spazio necessario per contenere il contenuto delle sezioni secondo quanto indicato. Infine copia il contenuto in memoria.  
Similarmente un file PE packed ha un header PE formattato con le informazioni da seguire, quindi il loader potrebbe caricare in memoria le sezioni oppure l'unpacking stub potrebbe creare le sezioni e caricarle in memoria.  

.2 Un file PE *non-packed* contiene una sezione che indical al loader quali funzione importare e un'altra sezione che contiene gli indirizzi dei nomi di tutte le funzioni importate. Quando il Windows loader legge le informazioni sugli import, determina quali funzioni sono necessarie e compila quindi gli indirizzi a cui trovarle.  

Nel caso di file *packed*, il loader non è in grado di leggere le informazioni sugli import. L'*unpacking stub* risolve gli import e tale operazione può essere svolta in modi diversi:
1. l'*unpacking stub* importa solo `LoadLibrary` e `GetProcAddress` per caricare la DLL in memoria per ogni libreria necessaria e poi recuperare l'indirizzo della procedure
2. tutti gli import sono visibili in quanto non protetti dal packer che è usato solo per motivi di compressione del codice
3. similarmente al punto 2, la import address table è parzialmente leggibile e quindi alcuni import sono protetti dal packer e altri no. In questo modo si riduce il lavoro a carico dell'*unpacking stub*
4. l'import address table non contiene nessuna informazione, neanche relative a `LoadLibrary` e `GetProcAddress`. In questo caso l'*unpacking stub* deve prima risolvere gli indirizzi di `LoadLibrary` e `GetProcAddress` e poi procedere come al punto 1.


.3 Infine, l'esecuzione deve passare all'eseguibile originale e il modo più semplice è effettuando un `jmp` all'OEP del file. Alcuni packer tendono a nascondere questa istruzione, definita **tail jump**, usando istruzioni `ret` o `call` o funzioni di sistema come `NtContinue` o `ZwContinue`.  

## Determinare se un file è *packed*

Alcuni indicatori utili a determinare se un file è *packed* sono:
- gli import sono ridotti allo stretto necessario, `LoadLibrary` e `GetProcAddress`
- le sezioni del file PE hanno nomi non comuni
- la dimensioni delle sezioni, ad esempio `.text`, sono fuori dal comune: *Size of Raw Data* = 0  e *Virtual Size* != 0

### Calcolo dell'entropia

L'entropia rappresenta il grado di *disordine* in un sistema o programma.  
Dati compressi o crittografati sono molto simili a dati casuali rispetto a dati non crittografati o compressi.  
L'analisi quindi dell'entropia di un file è utile per determinare se un file è *packed* o contiene dati crittografati od operazioni di crittografia.  

# Unpacking

Esistono diversi modi per effettuare l'unpacking di file PE.  

Innanzitutto esistono programmi che permettono di eseguire l'unpacking in maniera **automatica**. Questi programmi possono analizzare staticamente il file, quindi senza eseguirlo, ed essere in grado di decomprimere/decrittografare il contenuto dell'unpacking stub in linea, oppure salvare il risultato come file su disco.  

In alternativa a programmi automatici per l'unpacking statico, esistono programmi che effettuano l'unpacking automatico dinamico. Per usare questi programmi è necessario creare un ambiente sicuro per l'esecuzione del file PE.  
L'unpacker attende che l'unpacking stub estragga il file PE che viene salvato su disco e successivamente l'unpacker ricostruisce l'import address table.  

Esistono poi tecniche per l'unpacking manuale, principalmente due:
1. scoprire l'algoritmo del packer e ripeterla al contrario in modo da annullare le modifiche apportate dal packer. Questo metodo è più complesso e richiede tempo
2. lasciare che l'unpacking stub faccia il suo dovere, salvare su disco il dump del processo caricato in memoria (da debugger), correggere manualmente l'header PE in modo che il programma sia completo

**Esempio di unpacking usando OllyDbg e il suo plug-in OllyDump.**  
Da OllyDbg: Plugins > OllyDump > Find OEP by Section Hop. Il debugger colpisce il breakpoint appena prima che l'OEP sia eseguito.  

A questo punto tutto il codice è già stato spacchettato ed è pronto in memoria. Prendere nota dell'indirizzo a cui si è fermato il debugger in quanto corrisponde all'OEP e successivamente effettuare il dump della memoria su disco: Plugins > OllyDump > Dump Debugged Process.  

L'entry point dell'eseguibile è posizionato al EIP corrente, che corrisponde all'OEP e la Import Address Table è ricostruita. 
È possibile che il debugger non riesca ad effetuare il dump dell'header dopo lo spacchettamento ritrovandoci quindi con l'header del file impacchetato. In questo caso è necessario procedere manualmente per correggere l'header e ricostruire la IAT.  

### Ricostruire la Import Table con ImpRec (o Scylla)

Partendo armati conoscendo l'OEP del file da spacchettare, in ImpRec inserire il RAV (Raw Virtual Address) dell'OEP e poi **IAT autosearch**.  
Una volta trovato, **GetImports**. Infine **Fix Dump**.  

### Come trovare l'OEP

Usare strumenti per l'**individuazione automatica** come **OllyDump** e il suo **Find OEP by Section Hop** è più semplice ma in alcuni potrebbe non funzionare.  
L'unpacking stub e il file eseguibile *packed* si trovano generalmente in due sezioni diverse, nel caso di OllyDbg avviene una detection quando è individuato il trasferimento di dati da una sezione all'altra. In quel caso il debugger interviene usando un metodo step-over o step-into.  

Col metodo **step-over**, il debugger non entra nel dettaglio delle istruzioni ma essendo che le istruzioni `call` sono usate per eseguire codice presente in altre sezioni... il metodo step-over, usato per evitare che OllyDbg etichetti come OEP l'indirizzo/funzione sbagliata, rischia di mancare l'OEP del tutto.  
Il metodo **step-into**, invece entra nel dettaglio di ogni istruzione `call` incrementando la probabilità di trovare l'OEP ma al tempo stesso di produrre più falsi positivi.  

Quando i metodi automatici falliscono bisogna ricercare l'OEP **manualmente**.  
Il metodo più semplice consiste nel ricercare il **tail jump** ossia l'ultima istruzione valida, che sia `jmp`, `ret` o altro, dell'unpacking stub che **salta** all'OEP.  
Questa istruzione è l'ultima istruzione valida prima di una serie di byte di padding e salta a un indirizzo *lontano*. A questo indirizzo, **prima** che il file sia spacchettato, non si trovano istruzioni intelligibile ma solo padding. **Dopo** lo spacchettamento invece si trovano delle istruzioni in chiaro e valide.  

### Ricostruire la Import Table manualmente

La Import Table è formata da due tabelle, una contiene i nomi degli import mentre l'altra gli indirizzi in memoria.  
Per ostacolare l'analisi del malware, l'autore può decidere di eliminare la tabella con i nomi. In questo caso, l'analista di malware, deve determinare manualmente quali funzioni importa il malware.  

Quando, durante l'analisi statica, l'analista trova una chiamata a un indirizzo di memoria che non si trova nel range di indirizzi del file analizzato, può risalire al nome della funzione ricercando tale indirizzo in un debugger come OllyDbg.  

Alla conclusione, dopo aver rinominato tutte le funzioni o comunque un numero sufficiente a procedere con l'analisi, la import table serve per l'analisi statica mentre per quella dinamica è possibile utilizzare il programma *packed*.  

### Packer comuni | Tips and Tricks

**UPX** o *Ultimater Packer for eXecutables* è un packer gratuito e opensource utilizzato per la sua velocità di compressione e requisiti ridotti.  
Non pone particolare resistenza al reverse engineering, il tail jump è facilmente individuabile e lo stesso UPX offre lo switch -d per spacchettare un file impacchettato.  
È possibile trovare file che usano una versione di UPX custom ma è comunque possibile individuare l'OEP ed eventualmente ricostruire la IAT.  

**PECompact** è un packer commerciale che impiega tecniche di anti-debugging e codice offuscato. Per individuare il tail jump cercare una istruzione `jmp eax` seguito da diversi 0x00 byte.  

**ASPack** è un packer incentrato sulla sicurezza e impiega tecniche anti-unpacking e codice polimorfico.  
Per individuare l'OEP è necessario utilizzare breakpoint hardware sull'istruzione `PUSHAD` in lettura.  
Il breakpoint scatta quando la corrispondente chiamata `POPAD` è invocata, il tail jump si trova qualche istruzione in là.  

**Petite** simile ad ASPack e si differenzia per l'uso di tecniche di anti-debugging in particolare l'analisi single-step/step-into.  

Per individuare il breakpoint ripetere l'operazione per ASPack.  
Inoltre Petite include un import per ogni libreria dalla IAT originale. Anche se rimane comunque difficile ricostruire la IAT, è possibile individuare quali DLL usa il programma.  

**WinUnpack** non è incentrato sulla sicurezza ma sono comunque utilizzate tecniche che rendono l'individuazione dell'OEP, automaticamente e manualmente, complicato.  
Il tail jump non è semplice da individuare perché si trova nel mezzo di altre istruzioni che eseguono diversi salti prima di arrivare all'ultimo salto verso l'OEP (`jmp` e poi `ret`).  

Il salto è generalmente corto. Alcune tecniche per facilitare l'individuazione sono breakpoint per `GetModuleHandleA` per GUI e `GetCommandLineA` per CLI, funzioni che in Windows sono invocate poco dopo l'OEP.  

**Themida** impiega teniche di anti-debugging e anti-analysis.  
Contiene teniche per prevenire l'analisi in VMWare, debugger e Process Monitor. Ha anche una componente kernel, quindi senza restrizioni, che eventuali programmi di analisi in user mode non possono analizzare.  

In questi casi è utile ricorrere a software che permette di effettuare il dump dei processi dalla memoria, come [ProcDump](https://learn.microsoft.com/it-it/sysinternals/downloads/procdump) di Microsoft.  

Il dump contiene l'immagine in memoria del file spacchettato che non combacia al 100% con l'immagine del file originale ma è comunque utile per effettuare l'analisi del malware.  

In conclusione, non è sempre necessario effettuare l'unpacking dei malware in quanto l'analisi dinamica o l'analisi del dump dalla memoria potrebbero bastare.  
Alcuni malware non spacchettato l'intero file ma solo le sezioni necessarie al funzionamento in un dato momento.  

In ogni caso il reverse engineering richiede tempo ma ottiene il risultato di spacchettare l'intero file e di raccogliere informazioni e dettagli utili, ad esempio per scrivere script di unpacking.  

### DLL *packed*  

L'analisi delle DLL impacchettate non è molto differente dai file .exe.  

La export table di una DLL punta all'indirizzo delle funzioni esportte e se la DLL è *packed* allora anche le funzioni lo sono.  

L'OEP nelle DLL è l'inizio di *DllMain*. L'indirizzo di start elencato in una DLL *packed* è l'inizio dell'unpacking stub.  

Potrebbe essere difficile analizzare in un debugger il DllMain perché invocato prima che il debugger intervenga. In questi casi è utile modificare da **1** a **0** il bit all'indirizzo `0x2000` nell'`IMAGE_FILE_HEADER `per far sì che il file sia interpretato come eseguibile e non come DLL.  

Avviare l'analisi, individuare l'OEP e applicare le teniche di unapcking necessarie e poi ripristinare il bit da **0** a **1**.  

