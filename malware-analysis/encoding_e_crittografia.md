## XOR

Il XOR cipher (codice) è simile al Ceaser Cipher (ROTx) in quanto data una chiave per ogni valore che costituisce il messaggio plaintext viene eseguita una operazione XOR.  
Ad esempio, data la chiave di cifratura 0x3C e la lettera in chiaro **A** (0x41), il risultato è **}** (0x7f).

I vantaggi dello XOR sono che è reversibile, semplice da usare e occupa una sola operazione assembly.

### Single-byte XOR encoding

Algoritmo XOR ma con una singola chiave uguale per ogni byte da cifrare.

Essendo la chiave una costante, è possibile tentare operazioni di brute-forcing sul codice criptato tentando i 256(-1) valori validi.  
La prima chiave avrà come valore `0x1`, la seconda `0x2` e così via.

Nel caso in cui sia necessario tentare il brute force su più file PE, una buona tecnica consiste nel preparare una sorta di rainbow table andando ad effettuare operazioni XOR su stringhe o altri elementi noti, per ogni possibile chiave.  
A questo punto, ricercando e confrontando direttamente i file PE con questa "rainbow table XOR-edition" si risale immediatamente alla chiave utilizzata.  

Operazioni XOR su byte NULL espongono la chiave utilizzata: ad esempio, XOR su 0x00 con chiave 0x12 risulta in 0x12.  
Versioni custom di operazioni XOR implementate da malware non eseguono operazioni su byte NULL o che corrispondono alla chiave utilizzata, in questo modo limitando l'esposizione della chiave (**NULL-preserving XOR**).  

## Base64

Rappresentazione in caratteri ASCII di un file binario, composto da 64 caratteri.

L'encoding in Base64 avviene nel seguente modo. Prendendo come esempio la stringa *ATT*, si considera la rappresentazione hex della letter A ovvero 0x41.  
Ogni 3 byte di plaintext sono generati 4 caratteri Base64. Se una stringa non è multiplo di 4, allora è corrotta/malformata ed è possibile sistemarla aggiungendo del padding alla fine della stringa.
La chiave usata per la codifica è una stringa di 64 caratteri alfanuerica (maiuscole e minuscoe), segno + e forward slash.  

La personalizzazione della chiave, che deve rispettare la lunghezza di 64 caratteri, rende l'encoding in base64 più difficile da decodificare.

Gli 8 bit che costituiscono il valore 0x41 sono divisi in un gruppo da 6 bit e uno da 2 bit. Il gruppo da 6 bit è calcolato nella forma Base64. I restanti 2 bit sono aggrwgati ai primi 4 bit della lettera *T*.

|||A|T|T|
|-|-|-|-|-|
|Hex||0x4/0x1|0x5/0x4|0x5/0x4|
|Binario||0100/0001|0101/0100|0101/0100|
|Valore 6bit||16-21|-17|-20|
|Base64||Q|V|R|U|


## Individuare contenuto crittografato

Esistono diversi metodi per capire se il malware che si sta analizzando contiene del codice crittografato: ricercando stringhe e import relative a librerie legate alla crittografia, usando plugin di strumenti di analisi creati appositamente per la ricerca di costanti legate ad algoritmi di crittografia (come [FindCrypt2](https://hex-rays.com/blog/findcrypt2/) per IDA e [KANal](https://github.com/wolfram77web/app-peid/tree/master/plugins) per PEiD), o analizzando l'entropia del file e concentrandosi sulle aree dove questa risulta maggiore.

Quest'ultimo metodo può risultare in falsi positivi in quando alcuni tipi di file, come immagini, video, audio o in generale file compressi, risultano avere alti livelli di entropia rendendoli difficili da distinguere da file criptati.

Nel caso di algoritmi *custom*, casi in cui strumenti automatizzati falliscono, è possibile identificarne la presenza osservando gli input e gli outout ricevuti e generati dal malware. Generalmente le funzioni di decriptazione/decoding o di crittografia/encoding si trovano nelle non molto distanti da input e output, appunto.  


## Usare il malware stesso per decriptare file e contenuto

Nel caso di crittografia reversibile, è possibile predisporre quanto necessario per utilizzare le funzioni interne al malware e decriptare eventuali file e informazioni.  

Scrivendo script o compilando programmi (anche di poche righe) che permettono la manipolazione della memoria accessibile al malware ed eventuali parametri passati alle funzioni di crittografia, è possibile direzionare il malware contro sè stesso.  
ImmunityDebugger, ad esempio, permette l'uso di Python per creare script che guidano il comportamento del programma interagendo con lo spazio di memoria nel Debugger accessibile al malware analizzato.  

