## Process Injection
[T1055](https://attack.mitre.org/techniques/T1055/)

- **VirtualAllocEx**: alloca spazio nella memoria di un altro processo  
- **WriteProcessMemory**: scrive dati allo spazio allocato  

### DLL Injection
[T1055.001](https://attack.mitre.org/techniques/T1055/001/)

La DLL Injection consiste nel alterare il funzionamento di un programma affinché questo carichi la DLL malevola.  
Il processo richiama la funzione `LoadLibrary` che carica in memoria la DLL passata come argomento. Viene caricata la funzione *DllMain* che contiene il codice malevolo che viene quindi eseguito nel contesto del processo obiettivo dell'injection e da questo originato.

Il primo step consiste nell'ottenere un handle del processo obiettivo*.

`CreateToolhelp32Snapshot`, `Process32First` e `Process32Next` sono utilizzate per *navigare* l'elenco di processi attivi fino a trovare quello *giusto*.  
(In rifeimento alla APC Injection, più sotto, l'individuazione del processo avviene allo stesso modo qui descritto. Siccome l'obiettivo è l'individuazione di un Thread sono utilizzate anche le funzioni `Thread32First` e `Thread32Next`. In alternativa la funzione `Nt/ZwQuerySystemInformation` restituisce tra i suoi valori `SYSTEM_PROCESS_INFORMATION`. Infine, `OpenThread`.)  
Una volta individuato, viene chiamata la funzione `OpenProcess` al fine di ottenere l'handle.   

Successivamente bisogna allocare lo spazio nel processo vittima e srivere in quello spazio il nome della libreria malevola.

`VirtualAllocEx` è usato per creare/allocare spazio nella memoria di un altro processo al fine di garantire spazio all'esecuzione del malware.  
`WriteProcessMemory` è usata per scrivere nello spazio allocato da `VirtualAllocEx` la stringa del nome della DLL malevola.

L'ultimo step consiste nella creazione di un Thread nel processo vittima al fine di forzare il caricamento della DLL malevola.

`CreateRemoteThread` è l'API usata per creare thread in processo remoto. Questa API accetta tre argomenti: un handle a un processo (in questo caso il processo vittima), un indirizzo di avvio del thread e un argomento per il thread. Es, Handle al processo vittima, indirizzo che punta a LoadLibrary e il nome della DLL malevola come suo argomento.  

### Direct Injection

Molto simile alla Dll Injection, Direct Injection è una tecnica che consiste nell'effettuare injection direttamente nel processo vittima.  

### Process Replacement/Process Hollowing
[T1055.012](https://attack.mitre.org/techniques/T1055/012/)

Questa tecnica consiste nel caricare in memoria un processo relativo a un file eseguibile noto, come *svchost.exe*, ma sospendendone l'esecuzione del primo thread (Flag `dwCreationFlags` con valore 0x4 come parametro dell'API `CreateProcessA`).  
Una volta che il processo è sospeso in memoria, il malware si occupa di rilasciare tutta la memoria a cui puntano le sezioni del processo usando l'API `ZwUnmapViewOfSection`. Dopodiché viene allocata memoria con `VirtualAllocEx` per il malware per poi scrivere in ogni sezione, usando un loop, con `WriteProcessMemory`.  

Infine il maleware ripristina l'ambiente di esecuzione del processo con `SetThreadContext` e lo rimuove dallo stato di sospensione, `ResumeThread`.  

## Hook Injection

Un hook è un punto nel sistema di gestione dei messaggi in cui un'applicazione piò installare una subroutine per intercettare determinati eventi e messaggi del sistema e agire di conseguenza, ad esempio intercettando gli eventi generati da mouse e tastiera.  

- **Hook locale**: usato per osservare o manipolare messaggi destinati a un processo interno  
- **Hook remoto**: usato per osservare o manipolare messaggi destinati a un processo remoto (un altro processo nel sistema)  

Gli hook remoti si dividono in hook di alto livello e basso livello.  
Quelli di alto livello richiedono che la hook procedure sia un export di una DLL, che sarà poi mappata dal sistema operativo in un thread specifico o in tutti i thread.  
Quelli di basso livello richiedono che la hook procedure sia contenuta nel processo che installa l'hook.  

Un **keylogger** usa hooks sia di alto che di basso livello con le procedures `WH_KEYBOARD` e `WH_KEYBOARD_LL`.  
Nel primo caso, l'hook viene spesso eseguito nel contesto di un processo esterno. Nel secondo caso, invece, viene eseguito nel contesto del processo che l'ha creato.  

La principale funzione di Windows utilizzata per la creazione di hook è `SetWindowsHookEx`. Siccome un keylogger deve rimanere nascosto mentre scrive su file o comunque raccoglie gli input utente, viene usata la funzione `CallNextHookEx` per passare il messaggio notificato all'hook successivo ed evitare che altre applicazioni smettano di funzionare, o funzionino male, a causa di una notifica mai arrivata.  

## Detours

Detours è una libreria fornita da Microsoft Research nel 1999 e permette di modificare i file PE inserendo una nuova sezione, chiamata *.detours* la quale contiene una nuova Import Table. Questa libreria può essere facilmente utilizzata per creare versioni di file PE note, come notepad.exe, ma con DLL malevole nella Import Table.

## APC Injection
[T1055.004](https://attack.mitre.org/techniques/T1055/004/)

Ogni thread ha la propria coda APC che contiene codice/istruzioni da eseguire non appena il thread si trova in un *alertable state*, ovvero quando sono chiamate le funzioni `SleepEx`, `SignalObjectAndWait`, `WaitForSingleObjectEx`, `WaitForMultipleObjectsEx`, `MsgWaitForMultipleObjectsEx`.  
Queste funzioni lasciano tempo al trhead per processare la coda APC.  

Se un thread si trova in un alertable state ma prima che sia avviato, questo esegue direttamente le istruzioni presenti nella coda APC.  
Le istruzioni sono richiamate ed eseguite una per volta e quando la coda è vuota, il thread riprende la sua normale esecuzione.  

I malware possono sfruttare questo sistema per effettuare injection di codice malevolo in code APC di threads in alertable state e ottenere quindi esecuzione immediata del codice.  

### APC Injection dallo User-Space  

L'injection dallo User-space avviene dapprima ricercando threads nei processi in esecuzione che sia prossimo ad entrare in un alert state (richiamando le API elencate sopra)*. Invocando la funzione `QueueUserAPC`, si inserisce nella coda APC di un thread remoto il codice da eseguire.  


### APC Injection dal Kernel-Space

Malware che operano a livello di kernel, come i rootkit, non possono eseguire facilmente codice dallo user-space. Uno dei bypass è l'injection di codice in una coda APC di un processo/thread che viene eseguito appunto in user-space.  

Prima di tutto il malware crea la coda APC per un thread e lo popola con i corretti argomenti. La funzione `KeInitializeAPC` accetta diversi parametri che contengono informazioni utili a determinare se la coda APC sarà eseeguita in user-space (**NormalRoutine** e **APCMode**) e quale thread di quale processo è l'obiettivo (determinare a ritroso nel codice).  

Una volta che la coda è inizializzata, è passata a `KeInsertQueueAPC` che si oocupa di inserire l'oggetto APC nel thread indicato.  
